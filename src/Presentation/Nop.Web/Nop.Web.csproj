<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp3.1</TargetFramework>
    <Copyright>Copyright © Nop Solutions, Ltd</Copyright>
    <Company>Nop Solutions, Ltd</Company>
    <Authors>Nop Solutions, Ltd</Authors>
    <Version>4.3.0.0</Version>
    <Description>Nop.Web is also an MVC web application project, a presentation layer for public store and admin area.</Description>
    <PackageLicenseUrl>https://www.nopcommerce.com/license</PackageLicenseUrl>
    <PackageProjectUrl>https://www.nopcommerce.com/</PackageProjectUrl>
    <RepositoryUrl>https://github.com/nopSolutions/nopCommerce</RepositoryUrl>
    <RepositoryType>Git</RepositoryType>
    <!--Set this parameter to true to get the dlls copied from the NuGet cache to the output of your project-->
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
     <TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>
    <TypeScriptToolsVersion>Latest</TypeScriptToolsVersion>
    <SpaRoot>ClientApp\</SpaRoot>
    <DefaultItemExcludes>$(DefaultItemExcludes);$(SpaRoot)node_modules\**</DefaultItemExcludes>
 
    <!-- Set this to true if you enable server-side prerendering -->
    <BuildServerSideRenderer>true</BuildServerSideRenderer>
    <!--When true, compiles and emits the Razor assembly as part of publishing the project-->
    <RazorCompileOnPublish>false</RazorCompileOnPublish>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\Libraries\Nop.Core\Nop.Core.csproj" />
    <ProjectReference Include="..\..\Libraries\Nop.Data\Nop.Data.csproj" />
    <ProjectReference Include="..\..\Libraries\Nop.Services\Nop.Services.csproj" />
    <ProjectReference Include="..\Nop.Web.Framework\Nop.Web.Framework.csproj" />
  </ItemGroup>

  <ItemGroup>
       <!-- Don't publish the SPA source files, but do show them in the project files list -->
    <Content Remove="$(SpaRoot)**" />
    <None Include="$(SpaRoot)**" Exclude="$(SpaRoot)node_modules\**" />
    <!-- We copy the entire \App_Data directory. But we ignore JSON files and data protection keys  -->
    <Content Include="App_Data\**" CopyToPublishDirectory="PreserveNewest" Exclude="App_Data\*.json" />
    <Content Remove="App_Data\*.json" />
    <Content Update="App_Data\DataProtectionKeys\*.xml" CopyToPublishDirectory="Never" />

    <Compile Remove="Plugins\**;Themes\**" />
    <Content Remove="Plugins\**;Themes\**" />
    <EmbeddedResource Remove="Plugins\**;Themes\**" />
    <None Remove="Plugins\**;Themes\**" />

    <Content Include="Plugins\bin\placeholder.txt" CopyToPublishDirectory="PreserveNewest"/>
    <None Include="Plugins\**"  CopyToPublishDirectory="PreserveNewest" />

    <Content Include="Themes\**" CopyToPublishDirectory="PreserveNewest" Exclude="Themes\**\*.config;Themes\**\*.cshtml;Themes\**\*.json" />
    <None Include="Themes\**"  CopyToPublishDirectory="PreserveNewest" />

    <!-- We copy the \Logs directory -->
    <Content Include="Logs\**" CopyToPublishDirectory="PreserveNewest" />

    <None Update="Areas\Admin\sitemap.config">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

  <ItemGroup>
    <!-- This setting fixes the problem caused by this update in the websdk in vs2019
    https://github.com/aspnet/websdk/commit/7e6b193ddcf1eec5c0a88a9748c626775555273e#diff-edf5a48ed0d4aa5a4289cb857bf46a04
    Therefore, we restore the standard configuration behavior (there was no copy to the output directory) 
    in order to avoid the "Duplicate dll" error during publication. 
    We can also use “ExcludeConfigFilesFromBuildOutput” according to https://github.com/aspnet/AspNetCore/issues/14017 -->
    <Content Update="**\*.config;**\*.json" CopyToOutputDirectory="Never" CopyToPublishDirectory="PreserveNewest" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Plugins\" />
  </ItemGroup>

  <!-- This target execute after "Build" target.
    We use it to clean up folder with plugins from unnecessary and obsolete libraries. -->
  <Target Name="NopTarget" AfterTargets="Build">
    <ItemGroup>
      <!-- Get plugin description files to get plugin paths -->
      <PluginsDescription Include="$(MSBuildProjectDirectory)\Plugins\**\plugin.json;" />
      <!-- Get paths for all plugins -->
      <PluginsFolders Include="@(PluginsDescription->'%(relativedir)')" />

      <!-- Get all the libraries from the shadow copy folder to remove them,
        because depending on the settings, this may not happen when the application is starting,
        but this can lead to unpredictable results during debugging of the project. -->
      <ShadowCopiesLibraries Include="$(MSBuildProjectDirectory)\Plugins\bin\*.*" Exclude="$(MSBuildProjectDirectory)\Plugins\bin\placeholder.txt" />

      <!-- Get paths for ClearPluginAssemblies project -->
      <ClearPluginAssemblies Include="$(MSBuildProjectDirectory)\..\..\Build\ClearPluginAssemblies.proj" />

    </ItemGroup>
    <PropertyGroup>
      <PluginsFolders>@(PluginsFolders)</PluginsFolders>
    </PropertyGroup>
    <!-- Delete libraries from the shadow copy folder -->
    <Delete Files="@(ShadowCopiesLibraries)" />
    <!-- When .NET Core builds a project, it copies all referenced libraries to the output folder.
      For plugins it creates too many unnecessary files that just take up space.
      At the moment you can't disable this behavior. That's why we have to manually delete all unnecessary libraries from plugin output directories. -->
    <MSBuild Projects="@(ClearPluginAssemblies)" Properties="PluginPath=$(PluginsFolders)" Targets="NopClear" />

  </Target>

  <PropertyGroup>
    <!--The common language runtime (CLR) supports two types of garbage collection:
      workstation garbage collection, which is available on all systems, and server garbage collection,
      which is available on multiprocessor systems.
      
      For single-processor computers, the default workstation garbage collection should be the fastest option.
      Either workstation or server can be used for two-processor computers.
      Server garbage collection should be the fastest option for more than two processors.
      
      More details about GC you can see here: https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals-->
    <ServerGarbageCollection>false</ServerGarbageCollection>
    <!--In workstation or server garbage collection, you can enable concurrent garbage collection,
      which enables threads to run concurrently with a dedicated thread that performs the garbage
      collection for most of the duration of the collection.
      
      Concurrent garbage collection enables interactive applications to be more responsive by
      minimizing pauses for a collection. Managed threads can continue to run most of the time while
      the concurrent garbage collection thread is running. This results in shorter pauses while
      a garbage collection is occurring.
      
      To improve performance when several processes are running, disable concurrent garbage collection.
      
      More details here: https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals#concurrent-garbage-collection-->
    <ConcurrentGarbageCollection>false</ConcurrentGarbageCollection>
  </PropertyGroup> 
<UsingTask TaskName="ReplaceFileText" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <InputFilename ParameterType="System.String" Required="true" />
      <OutputFilename ParameterType="System.String" Required="true" />
      <MatchExpression ParameterType="System.String" Required="true" />
      <ReplacementText ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[  
          File.WriteAllText(
            OutputFilename,
            Regex.Replace(File.ReadAllText(InputFilename), MatchExpression, ReplacementText)
            );
        ]]>
      </Code>
    </Task>
  </UsingTask>
  
  <Target Name="EnsureNodeEnv" BeforeTargets="ResolveTagHelperRazorGenerateInputs" Condition="!Exists('$(SpaRoot)node_modules') ">
    <!-- Ensure Node.js is installed -->
    <Exec Command="node --version" ContinueOnError="true">
      <Output TaskParameter="ExitCode" PropertyName="ErrorCode" />
    </Exec>
    <Error Condition="'$(ErrorCode)' != '0'" Text="Node.js is required to build and run this project. To continue, please install Node.js from https://nodejs.org/, and then restart your command prompt or IDE." />
    <Message Importance="high" Text="Restoring dependencies using 'npm'. This may take several minutes..." />
    <Exec WorkingDirectory="$(SpaRoot)" Command="npm install" />
  </Target>
  
  <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
    <FontendBuildCommand>npm run build</FontendBuildCommand>
    <FontendBuildSSRCommand>npm run build</FontendBuildSSRCommand>
    <FontendRunCommand>npm start</FontendRunCommand>
  </PropertyGroup>
  
  <PropertyGroup Condition="'$(Configuration)' == 'Release'">
    <FontendBuildCommand>npm run build:production</FontendBuildCommand>
    <FontendBuildSSRCommand>npm run build:ssr:production</FontendBuildSSRCommand>
  </PropertyGroup>
  
  <Target Name="BuildFrontEnd" DependsOnTargets="EnsureNodeEnv" AfterTargets="EnsureNodeEnv" Condition=" !Exists('$(SpaRoot)dist')">
    <Message Importance="high" Text="Cleaning angular build...." />
    <ItemGroup>
      <FilesToDelete Include="$(SpaRoot)dist\**; wwwroot\dist\**" />
    </ItemGroup>
    <Delete Files="@(FilesToDelete)" />
    <RemoveDir Directories="ClientApp\dist; wwwroot\dist" />
    <Message Importance="high" Text="Building the client side angular App...." />
    <Exec WorkingDirectory="$(SpaRoot)" Command="$(FontendBuildCommand)" />
    <Message Importance="high" Text="Building the server side rendered angular App...." Condition=" '$(BuildServerSideRenderer)' == 'true' " />
    <Exec WorkingDirectory="$(SpaRoot)" Command="$(FontendBuildSSRCommand)" Condition=" '$(BuildServerSideRenderer)' == 'true' " />
    <Exec Command="robocopy  wwwroot\dist\ wwwroot\dist\en-in\" IgnoreExitCode="true" />
    <!--<ReplaceFileText InputFilename="wwwroot\dist\index.html" OutputFilename="Views\Home\Index.cshtml" MatchExpression="&lt;app-root&gt;Loading...&lt;\/app-root&gt;" ReplacementText=" " />-->
  </Target>

  <Target Name="PublishRunWebpack" AfterTargets="ComputeFilesToPublish">
    <!-- Include the newly-built files in the publish output -->
    <ItemGroup>
      <DistFiles Include="$(SpaRoot)dist\**;" />
      <DistFiles Include="$(SpaRoot)node_modules\**" Condition="'$(PublishNodeModules)' == 'true'" />
      <SpaDistFiles Include="wwwroot\dist\**" />
      <ResolvedFileToPublish Include="@(DistFiles->'%(FullPath)')" Exclude="@(ResolvedFileToPublish)">
        <RelativePath>%(DistFiles.Identity)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <ResolvedFileToPublish Include="@(SpaDistFiles->'%(FullPath)')" Exclude="@(ResolvedFileToPublish)">
        <RelativePath>%(SpaDistFiles.Identity)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>

</Project>